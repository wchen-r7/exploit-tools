#!/usr/bin/env python
# By: Zachary Cutlip
# Twitter: @zcutlip
# upload a file to a system via telnet session
# e.g., use to bootstrap a more capable file transfer program
# onto a system where you only have telnet access

# 
#  Copyright (c) 2012, Tactical Network Solutions, Zachary Cutlip <zcutlip@tacnetsol.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#


import binascii
from telnetlib import Telnet
from getopt import GetoptError, getopt as GetOpt
import os
import time
import math
import sys
import hashlib

WAIT_TIME = 0.2
BLOCKSIZE=64
ESCAPE="\\\\x"
PROMPT=": "
PORT = 23

FILENAME=None
DESTINATION_FILE=None
HOST=None

USERNAME=None
PASSWORD=None
READ_PASS_STDIN=False

class Logging:
    WARN=0
    INFO=1
    DEBUG=2
    prefixes=[]
    prefixes.append(" [!] ")
    prefixes.append(" [+] ")
    prefixes.append(" [@] ")
    @classmethod
    def log_msg(klass,msg,level=INFO):
        pref=Logging.prefixes[level]
        print pref+msg

def pass_from_stdin():
    passwd=sys.stdin.readline().rstrip('\r\n')
    return passwd

def do_tn_login(tn):
    Logging.log_msg("Logging in.")
    if USERNAME:
        tn.read_until(PROMPT)
        tn.write(USERNAME+"\n")
    if PASSWORD:
        tn.read_until(PROMPT)
        tn.write(PASSWORD+"\n")
    


def print_progress(bytes_written,total_bytes):
    percent=(bytes_written/float(total_bytes))*100
    marks=int(math.floor(percent / 2))
    dots=50-marks
    markstring="#"# marks
    dotstring="."# dots
    sys.stdout.write("\r[%s%s] %0.2f%%"%(markstring,dotstring,percent))
    sys.stdout.flush()

def md5sum(filename):
    f=open(filename,'rb')
    h=hashlib.md5()
    while True:
        data=f.read(8192)
        if not data:
            break
        h.update(data)
    return h.hexdigest()

def usage():
    print ""
    print "%s [OPTIONS]" % sys.argv[0]
    print ""
    print "Required Arguments:"
    print "\t-t, --target=<ip>              Target IP address"
    print "\t-s, --source=<file path>       Local file path"
    print "\t-d, --destination=<file path>  Remote file path"
    print ""
    print "Optional Aguments:"
    print "\t-l, --login=<login>            Login username"
    print "\t-a, --password=<password>      Login password"
    print "\t-A, --stdin-password           Read password from standard input"
    print "\t-p, --port=<port>              Port to telnet to [%d]" % PORT
    print "\t-e, --escape=<string>          Hex escape string ['%s']" % ESCAPE
    print "\t-P, --prompt=<string>          Username / password prompt string ['%s']" % PROMPT
    print "\t-w, --time=<float>             Wait period between echo commands [%s seconds]" % WAIT_TIME
    print "\t-b, --blocksize=<int>          Number of bytes to transfer per echo command [%s bytes]" % BLOCKSIZE
    print "\t-h, --help"
    print ""

try:
    opts, args = GetOpt(sys.argv[1:], "hs:d:w:b:e:t:l:p:L:P:a:A", ["help", "source=", "destination=", "time=", "blocksize=", "escape=", "target=", "login=", "password=", "prompt=", "--stdin-password"])

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
            sys.exit(1)
        elif opt in ("-s", "--source"):
            FILENAME = arg
        elif opt in ("-d", "--destination"):
            DESTINATION_FILE = arg
        elif opt in ("-w", "--time"):
            WAIT_TIME = float(arg)
        elif opt in ("-b", "--blocksize"):
            BLOCKSIZE = int(arg)
        elif opt in ("-e", "--escape"):
            ESCAPE = arg
    elif opt in ("-p", "--port"):
        PORT = arg
    elif opt in ("-P", "--prompt"):
        PROMPT = arg
        elif opt in ("-t", "--target"):
            HOST = arg
        elif opt in ("-l","--login"):
            USERNAME = arg
        elif opt in ("-a","--password"):
            PASSWORD = arg
        elif opt in ("-A", "--stdin-password"):
            READ_PASS_STDIN=True

except GetoptError, e:
    print e

if HOST is None or FILENAME is None or DESTINATION_FILE is None:
    usage()
    sys.exit(1)
elif not os.path.isfile(FILENAME):
    print "ERROR: '%s' is not a file!" % FILENAME
    sys.exit(1)

if READ_PASS_STDIN:
        PASSWORD=pass_from_stdin()

tn=Telnet(HOST, PORT)

if USERNAME is not None or PASSWORD is not None:
    do_tn_login(tn)

command=("rm %s\n"%DESTINATION_FILE)
tn.write(command)
read_bytes=tn.read_very_eager()

Logging.log_msg("Removed %s from server."%DESTINATION_FILE)
Logging.log_msg("Uploading file:\t%s\n\t\t to:\t%s:%s"%(FILENAME,HOST,DESTINATION_FILE))
Logging.log_msg("MD5 digest: %s"%md5sum("./%s"%FILENAME))

count=0
done=False

f=open("./%s"%FILENAME,'rb')
f.seek(0,2)
total_bytes=f.tell()
f.seek(0)

while(not done):
    data=f.read(BLOCKSIZE)
    count+=len(data)
    if len(data) == 0:
        break
    elif len(data) < BLOCKSIZE:
        done=True
    
    string=""
    for byte in data:
        string+=ESCAPE+binascii.b2a_hex(byte)

    command="echo -e -n \""+string+"\" >> %s\n"%DESTINATION_FILE

    tn.write(command)
  
    print_progress(count,total_bytes)
    time.sleep(WAIT_TIME)
    
    read_bytes=tn.read_very_eager()

print ("\n\n")


